#!/bin/bash

# Define color variables
CYAN="$(printf '\033[36m')"
GREEN="$(printf '\033[32m')"
ORANGE="$(printf '\033[33m')"
BLUE="$(printf '\033[34m')"
RED="$(printf '\033[31m')"
RESETBG="$(printf '\e[0m\n')"

# Commit Commands Menu
commit_commands_menu() {
    while true; do
        clear
        echo -e "${RED}Commit Commands Options:${RESETBG}"
        echo -e "${RED}[${WHITE}1${RED}]${ORANGE} Commit changes with a message ${GREEN}git commit -m 'message'"
        echo -e "${RED}[${WHITE}2${RED}]${ORANGE} Amend the last commit ${GREEN}git commit --amend"
        echo -e "${RED}[${WHITE}3${RED}]${ORANGE} Commit only specific files ${GREEN}git commit file_name -m 'message'"
        echo -e "${RED}[${WHITE}4${RED}]${ORANGE} Skip staging and commit directly ${GREEN}git commit -a -m 'message'"
        echo -e "${RED}[${WHITE}0${RED}]${ORANGE} Back to main menu"
        echo
        read -p "${RED}[${WHITE}-${RED}]${GREEN} Select an option: ${BLUE}" selected

        case $selected in
            1) commit_with_message ;;
            2) amend_last_commit ;;
            3) commit_specific_files ;;
            4) skip_staging_and_commit ;;
            0) break ;;  # Exit the loop and return to the main menu
            *) echo -e "${RED}Invalid option! Please try again.${RESETBG}" ;;
        esac

        read -p "${GREEN}Press [Enter] to return to the menu...${RESETBG}"
    done
}

# Display Git status
git_status() {
    echo -e "${GREEN}Current Git status:${RESETBG}"
    git status -s
}

# Commit with a message
commit_with_message() {
    git_status
    read -p "${GREEN}Enter the commit message: ${BLUE}" message
    if [[ -z "$message" ]]; then
        echo -e "${RED}Error: Commit message cannot be empty.${RESETBG}"
        return
    fi
    git commit -m "$message" || echo -e "${RED}Error: Commit failed.${RESETBG}"
    echo -e "${GREEN}Changes have been committed with the message: '$message'.${RESETBG}"
}

# Amend the last commit
amend_last_commit() {
    git_status
    read -p "${GREEN}Are you sure you want to amend the last commit? (y/n): ${BLUE}" confirm
    if [[ $confirm == "y" || $confirm == "Y" ]]; then
        git commit --amend || echo -e "${RED}Error: Amend operation failed.${RESETBG}"
        echo -e "${GREEN}The last commit has been amended.${RESETBG}"
    else
        echo -e "${RED}Amend operation canceled.${RESETBG}"
    fi
}

# Commit specific files
commit_specific_files() {
    git_status
    read -p "${GREEN}Enter the file name(s) to commit (space-separated): ${BLUE}" files
    read -p "${GREEN}Enter the commit message: ${BLUE}" message

    if [[ -z "$files" || -z "$message" ]]; then
        echo -e "${RED}Error: File(s) and commit message cannot be empty.${RESETBG}"
        return
    fi

    # Split files into an array
    IFS=' ' read -r -a files_array <<< "$files"

    # Check if files exist and are tracked by Git
    for file in "${files_array[@]}"; do
        if [[ -z $(git ls-files "$file") ]]; then
            echo -e "${RED}Error: File '$file' not found or not tracked by Git.${RESETBG}"
            return
        fi
    done

    # Stage and commit the files
    git add "${files_array[@]}" && git commit -m "$message"
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}File(s) '${files_array[*]}' have been committed with the message: '$message'.${RESETBG}"
    else
        echo -e "${RED}Error: Commit failed.${RESETBG}"
    fi
}

# Skip staging and commit directly
skip_staging_and_commit() {
    git_status
    read -p "${GREEN}Enter the commit message: ${BLUE}" message
    if [[ -z "$message" ]]; then
        echo -e "${RED}Error: Commit message cannot be empty.${RESETBG}"
        return
    fi
    git commit -a -m "$message" || echo -e "${RED}Error: Commit failed.${RESETBG}"
    echo -e "${GREEN}Changes have been committed directly with the message: '$message'.${RESETBG}"
}

# Start the menu
commit_commands_menu